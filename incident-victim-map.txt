import sqlite3
import pandas as pd
import dash
from dash import dcc, html
from dash.dependencies import Input, Output
import plotly.express as px

########################################
# Step 1: Connect to the database and load data
########################################

db_path = "FinalProject.db"  # Update with the correct path to your DB file

conn = sqlite3.connect(db_path)

# Query to retrieve victim ratio data
query_victim_ratio = """
SELECT 
    Locations.StateName AS Location,
    Victims.VictimKilled AS Victims_Killed,
    Victims.VictimInjured AS Victims_Injured,
    Incidents.IncidentDate
FROM 
    Incidents
NATURAL JOIN 
    Locations
NATURAL JOIN 
    Victims;
"""
victim_data = pd.read_sql_query(query_victim_ratio, conn)

# Query for incident counts
query_incident_count = """
SELECT 
    Locations.StateName AS State,
    Incidents.IncidentDate,
    COUNT(Incidents.IncidentID) AS IncidentCount
FROM 
    Incidents
JOIN 
    Locations
ON 
    Incidents.LocationID = Locations.LocationID
GROUP BY 
    Locations.StateName, Incidents.IncidentDate
"""
incident_data = pd.read_sql_query(query_incident_count, conn)
conn.close()

########################################
# Step 2: Preprocess Victim Ratio Data
########################################

victim_data['IncidentDate'] = pd.to_datetime(victim_data['IncidentDate'])
victim_data['IncidentMonth'] = victim_data['IncidentDate'].dt.strftime('%m')
victim_data['Total_Victims'] = victim_data['Victims_Killed'] + victim_data['Victims_Injured']

# Group by location and month
grouped_victim = victim_data.groupby(['Location', 'IncidentMonth']).agg({
    'Total_Victims': 'sum',
    'Victims_Killed': 'sum'
}).reset_index()

grouped_victim['Victim_Ratio'] = grouped_victim.apply(
    lambda row: (row['Victims_Killed'] / row['Total_Victims']) * 100 if row['Total_Victims'] > 0 else 0,
    axis=1
)

# All months combined for victim ratio
all_months_victim = grouped_victim.groupby('Location').agg({
    'Total_Victims': 'sum',
    'Victims_Killed': 'sum'
}).reset_index()

all_months_victim['Victim_Ratio'] = all_months_victim.apply(
    lambda row: (row['Victims_Killed'] / row['Total_Victims']) * 100 if row['Total_Victims'] > 0 else 0,
    axis=1
)
all_months_victim['IncidentMonth'] = 'All'

complete_victim_data = pd.concat([grouped_victim, all_months_victim], ignore_index=True)

########################################
# Step 3: Preprocess Incident Count Data
########################################

incident_data['IncidentDate'] = pd.to_datetime(incident_data['IncidentDate'])
incident_data['IncidentMonth'] = incident_data['IncidentDate'].dt.strftime('%m')

incident_grouped = incident_data.groupby(['State', 'IncidentMonth'], as_index=False)['IncidentCount'].sum()

# All months combined for incident count
all_months_incident = incident_data.groupby('State', as_index=False)['IncidentCount'].sum()
all_months_incident['IncidentMonth'] = 'All'

complete_incident_data = pd.concat([incident_grouped, all_months_incident], ignore_index=True)

########################################
# Step 4: State mapping and merging datasets
########################################

state_full_name_map = {
    'Alabama': 'AL', 'Alaska': 'AK', 'Arizona': 'AZ', 'Arkansas': 'AR',
    'California': 'CA', 'Colorado': 'CO', 'Connecticut': 'CT', 'Delaware': 'DE',
    'Florida': 'FL', 'Georgia': 'GA', 'Hawaii': 'HI', 'Idaho': 'ID',
    'Illinois': 'IL', 'Indiana': 'IN', 'Iowa': 'IA', 'Kansas': 'KS',
    'Kentucky': 'KY', 'Louisiana': 'LA', 'Maine': 'ME', 'Maryland': 'MD',
    'Massachusetts': 'MA', 'Michigan': 'MI', 'Minnesota': 'MN',
    'Mississippi': 'MS', 'Missouri': 'MO', 'Montana': 'MT', 'Nebraska': 'NE',
    'Nevada': 'NV', 'New Hampshire': 'NH', 'New Jersey': 'NJ',
    'New Mexico': 'NM', 'New York': 'NY', 'North Carolina': 'NC',
    'North Dakota': 'ND', 'Ohio': 'OH', 'Oklahoma': 'OK', 'Oregon': 'OR',
    'Pennsylvania': 'PA', 'Rhode Island': 'RI', 'South Carolina': 'SC',
    'South Dakota': 'SD', 'Tennessee': 'TN', 'Texas': 'TX', 'Utah': 'UT',
    'Vermont': 'VT', 'Virginia': 'VA', 'Washington': 'WA',
    'West Virginia': 'WV', 'Wisconsin': 'WI', 'Wyoming': 'WY'
}

# Map victim data location to abbreviation
complete_victim_data['Abbreviation'] = complete_victim_data['Location'].map(state_full_name_map)

# Map incident data states to abbreviation
complete_incident_data['Abbreviation'] = complete_incident_data['State'].map(state_full_name_map)

# Merge victim and incident data (only states with data will remain)
merged_data = pd.merge(
    complete_victim_data[['Abbreviation', 'IncidentMonth', 'Victim_Ratio']],
    complete_incident_data[['Abbreviation', 'IncidentMonth', 'IncidentCount']],
    on=['Abbreviation', 'IncidentMonth'],
    how='outer'
)

# Filter out rows that have no data at all
# If a row has IncidentCount = NaN and Victim_Ratio = NaN, it means no data
merged_data = merged_data.dropna(subset=['IncidentCount', 'Victim_Ratio'], how='all')

# Also attach FullName for nicer tooltips, but only for those states we have
state_names = pd.DataFrame(list(state_full_name_map.items()), columns=['FullName', 'Abbreviation'])
combined_data = pd.merge(merged_data, state_names, on='Abbreviation', how='left')

########################################
# Step 5: Initialize Dash app and layout
########################################

app = dash.Dash(__name__)

app.layout = html.Div([
    html.H1("Incident & Victim Ratio Analysis Dashboard"),

    html.Label("Select Metric:"),
    dcc.Dropdown(
        id='metric-filter',
        options=[
            {'label': 'Incident Count', 'value': 'IncidentCount'},
            {'label': 'Victim Ratio (Killed/Total %)', 'value': 'Victim_Ratio'}
        ],
        value='IncidentCount',  # Default metric
        placeholder="Select a Metric"
    ),

    html.Label("Filter by Month:"),
    dcc.Dropdown(
        id='month-filter',
        options=[
            {'label': 'All Months', 'value': 'All'},
            {'label': 'January', 'value': '01'},
            {'label': 'February', 'value': '02'},
            {'label': 'March', 'value': '03'},
            {'label': 'April', 'value': '04'},
            {'label': 'May', 'value': '05'},
            {'label': 'June', 'value': '06'},
            {'label': 'July', 'value': '07'},
            {'label': 'August', 'value': '08'},
            {'label': 'September', 'value': '09'},
            {'label': 'October', 'value': '10'},
            {'label': 'November', 'value': '11'},
            {'label': 'December', 'value': '12'}
        ],
        value='All',  # Default month
        placeholder="Select a Month"
    ),

    dcc.Graph(id='choropleth-map')
])

########################################
# Step 6: Define callback for updating the map
########################################
@app.callback(
    Output('choropleth-map', 'figure'),
    [Input('metric-filter', 'value'),
     Input('month-filter', 'value')]
)
def update_map(selected_metric, selected_month):
    if selected_month == 'All':
        filtered_data = combined_data[combined_data['IncidentMonth'] == 'All']
        title_month = "All Months"
    else:
        filtered_data = combined_data[combined_data['IncidentMonth'] == selected_month]
        title_month = selected_month

    # Choose color scale differently depending on metric
    if selected_metric == 'IncidentCount':
        color_scale = px.colors.sequential.Reds
        title = f"Number of Incidents by State for {title_month}"
        color_label = "Number of Incidents"
    else:
        color_scale = px.colors.sequential.Reds
        title = f"Victim Ratio (Killed/Total %) by State for {title_month}"
        color_label = "Victim Ratio (%)"

    # If no data for that month, create an empty figure or handle gracefully
    if filtered_data.empty:
        fig = px.choropleth(scope="usa", title="No data available for this selection.")
        return fig

    fig = px.choropleth(
        filtered_data,
        locations="Abbreviation",
        locationmode="USA-states",
        color=selected_metric,
        color_continuous_scale=color_scale,
        scope="usa",
        title=title,
        labels={selected_metric: color_label},
        hover_name="FullName",
        hover_data={
            'FullName': True,
            'IncidentCount': True,
            'Victim_Ratio': True
        }
    )
    
    return fig

########################################
# Step 7: Run the app
########################################
if __name__ == '__main__':
    app.run_server(debug=True, port=9000)